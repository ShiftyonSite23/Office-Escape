<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>OFFICE ESCAPE — Isometric Maze (Workers)</title>
<style>
  :root{
    --bg:#0d1621; --ink:#e9f2ff; --muted:#7a8aa1;
    --tileA:#0f2030; --tileB:#13283b; --grid:#1e3a55;
    --wall:#b9c7d8; --desk:#8a5a28; --plant:#49b675;
    --playerSkin:#ffd4b5; --playerShirt:#dfe8ff; --playerTie:#e64b4b; --shadow:#081019aa;
    --btn:#1b2a3a; --btnOn:#21384f; --accent:#3ad1ff;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
  header{padding:.6rem 1rem;text-align:center;font-weight:800;letter-spacing:.4px}
  header span{opacity:.85;cursor:pointer}
  #hud{position:fixed;left:12px;top:12px;font:600 14px/1.1 system-ui;color:var(--ink);text-shadow:0 1px 0 #0006}
  #debug{position:fixed;left:12px;top:36px;font:12px/1.2 ui-monospace,Consolas,Monaco,monospace;color:var(--muted)}
  #wrap{display:flex;justify-content:center}
  canvas{display:block;touch-action:none;background:linear-gradient(135deg,var(--tileA),var(--tileB))}
  /* overlays */
  .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#000a;color:#e9f2ff}
  .panel{background:#0e1b2a;border:2px solid #31465f;border-radius:14px;padding:18px 22px;text-align:center}
  .panel h2{margin:0 0 6px}
  .panel button{background:#1b2a3f;color:#dfe9f6;border:2px solid #324b67;border-radius:10px;padding:10px 16px;font-weight:700}
  /* Mobile controls */
  #pad{position:fixed;left:0;right:0;bottom:0;display:flex;gap:14px;justify-content:center;align-items:end;padding:18px 14px 22px;background:linear-gradient(0deg,#000a,transparent)}
  .cluster{display:grid;grid-template-columns:repeat(3,68px);grid-template-rows:repeat(2,68px);gap:12px;align-items:center;justify-items:center}
  .btn{width:68px;height:68px;border-radius:16px;background:var(--btn);border:2px solid #0007;box-shadow:0 4px 14px #0006;display:flex;align-items:center;justify-content:center;color:#cfe7ff;font-size:26px;user-select:none}
  .btn:active{background:var(--btnOn)}
  .big{width:88px;height:88px;border-radius:20px;font-size:28px}
  @media (min-width:820px){
    .cluster{grid-template-columns:repeat(3,76px);grid-template-rows:repeat(2,76px)}
    .btn{width:76px;height:76px}
    .big{width:96px;height:96px}
  }
</style>
</head>
<body>
<header><span id="title">OFFICE ESCAPE — Isometric Maze</span></header>
<div id="hud">Coffee: <b id="coffee">0</b> • HP: <b id="hp">12</b></div>
<pre id="debug"></pre>
<div id="wrap"><canvas id="c" width="900" height="630"></canvas></div>

<!-- overlays -->
<div id="win" class="overlay"><div class="panel">
  <h2>Elevator Reached!</h2>
  <p>Nice. Refresh or tap below to play again.</p>
  <button id="againBtn">Play Again</button>
</div></div>
<div id="lose" class="overlay"><div class="panel">
  <h2>You were <span style="color:#ffda6b">FIRED</span>!</h2>
  <p>Coffee heals +2. Workers hurt on contact.</p>
  <button id="retryBtn">Retry</button>
</div></div>

<!-- MOBILE CONTROLS -->
<div id="pad">
  <div class="cluster" style="margin-right:18px">
    <div></div>                      <div class="btn" data-k="up">↑</div>     <div></div>
    <div class="btn" data-k="left">←</div> <div class="btn" data-k="down">↓</div> <div class="btn" data-k="right">→</div>
  </div>
  <div class="cluster" style="grid-template-columns:88px;grid-template-rows:88px">
    <div class="btn big" data-k="attack">✕</div>
  </div>
</div>

<script>
/* ========= helpers ========= */
const $=sel=>document.querySelector(sel);
const rnd=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const debug=$('#debug'); const coffeeEl=$('#coffee'); const hpEl=$('#hp');
let showDebug=true; $('#title').onclick=()=>{showDebug=!showDebug; debug.style.display=showDebug?'block':'none';};

const W=42, H=36;          // logical tiles
const TILE=28;             // isometric tile pitch
const cam={x:0,y:0};       // screen offset (follows player)
const keys={left:0,right:0,up:0,down:0,attack:0};
for (const b of document.querySelectorAll('.btn')) {
  const k=b.dataset.k;
  const on=e=>{e.preventDefault(); keys[k]=1;};
  const off=e=>{e.preventDefault(); keys[k]=0;};
  b.addEventListener('touchstart',on,{passive:false});
  b.addEventListener('touchend',off,{passive:false});
  b.addEventListener('touchcancel',off,{passive:false});
  b.addEventListener('mousedown',on); b.addEventListener('mouseup',off); b.addEventListener('mouseleave',off);
}
addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft'||e.key==='a')keys.left=1;
  if(e.key==='ArrowRight'||e.key==='d')keys.right=1;
  if(e.key==='ArrowUp'||e.key==='w')keys.up=1;
  if(e.key==='ArrowDown'||e.key==='s')keys.down=1;
});
addEventListener('keyup',e=>{
  if(e.key==='ArrowLeft'||e.key==='a')keys.left=0;
  if(e.key==='ArrowRight'||e.key==='d')keys.right=0;
  if(e.key==='ArrowUp'||e.key==='w')keys.up=0;
  if(e.key==='ArrowDown'||e.key==='s')keys.down=0;
});

/* ========= world ========= */
const FLOOR=0, SOLID=1, EXIT=2;
const grid=Array.from({length:H},()=>Array(W).fill(FLOOR));

// carve clean “open-cubicle” corridors (maze-ish but readable)
(function carve(){
  // frame + cubicle runs
  for(let y=1;y<H-1;y++) for(let x=1;x<W-1;x++){
    if((x%4===0 && y%3!==0) || (y%5===0 && x%6!==0)) grid[y][x]=SOLID;
  }
  // punch openings
  for(let i=0;i<130;i++){
    const x=rnd(2,W-3), y=rnd(2,H-3);
    if(grid[y][x]===SOLID && Math.random()<0.6) grid[y][x]=FLOOR;
  }
  // exit door
  grid[H-3][W-3]=EXIT;
})();

// pickups
const coffees=[];
for(let i=0;i<8;i++){
  let x,y; do{ x=rnd(2,W-3); y=rnd(2,H-3);}while(grid[y][x]!==FLOOR);
  coffees.push({x,y});
}

/* ========= player ========= */
const player={
  x: 3, y: 3, hp:12, coffee:0,
  speed: 4/60, // tiles/frame
  facing:1, step:0, iFrames:0
};
// spawn near top-left open tile
for(let y=2;y<8;y++){ for(let x=2;x<8;x++){ if(grid[y][x]===FLOOR){player.x=x;player.y=y;break;} } if(player.x)break; }
hpEl.textContent=player.hp;

/* ========= enemies: WORKERS (patrol) ========= */
const workers=[];
function spawnWorkers(){
  workers.length=0;
  const spots = [
    [12,6],[18,8],[24,14],[30,10],[36,20],[20,22],[10,18],[34,26]
  ];
  for(const [x,y] of spots){
    if(grid[y]&&grid[y][x]===FLOOR) workers.push({x,y,dir:1,t:0});
  }
}
spawnWorkers();
function stepWorkers(){
  for(const w of workers){
    w.t++;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    // candidates that are floor
    const opts=[];
    for(let d=0;d<4;d++){
      const nx=w.x+dirs[d][0], ny=w.y+dirs[d][1];
      if(inBounds(nx,ny) && grid[Math.round(ny)][Math.round(nx)]!==SOLID) opts.push(d);
    }
    // prefer continuing forward; otherwise pick non-backtracking
    let choice=w.dir;
    if(!opts.includes(choice) || w.t%60===0){
      const back=(choice^1);
      const cands=opts.filter(o=>o!==back);
      choice = (cands.length? cands[(Math.random()*cands.length)|0] : opts[(Math.random()*opts.length)|0]);
    }
    w.dir=choice;
    const sp=0.06; // slower than player
    const nx=w.x+dirs[w.dir][0]*sp, ny=w.y+dirs[w.dir][1]*sp*0.9;
    if(!solidAt(nx,ny)){ w.x=nx; w.y=ny; } else { w.dir^=1; }
    // contact damage (gentle)
    const dx=w.x-player.x, dy=w.y-player.y;
    if(dx*dx+dy*dy < 0.6*0.6 && player.iFrames<=0){
      player.hp = Math.max(0, player.hp-1);
      player.iFrames=45; // brief invulnerability after hit
      hpEl.textContent=player.hp;
    }
  }
}

/* ========= rendering ========= */
const c=$('#c'), ctx=c.getContext('2d');
const iso=(x,y)=>({ sx:(x - y)*TILE + c.width/2 + cam.x, sy:(x + y)*TILE/2 + 120 + cam.y });

function drawTile(x,y,kind){
  const {sx,sy}=iso(x,y);
  ctx.beginPath();
  ctx.moveTo(sx,sy-TILE/2);
  ctx.lineTo(sx+TILE,sy);
  ctx.lineTo(sx,sy+TILE/2);
  ctx.lineTo(sx-TILE,sy);
  ctx.closePath();
  if(kind===FLOOR){
    ctx.fillStyle = ( (x+y)&1 ) ? '#12263a' : '#0f2030';
    ctx.fill(); ctx.strokeStyle='#19324a'; ctx.stroke();
  } else if(kind===SOLID){
    ctx.fillStyle='#c9d6e5'; ctx.fill();
    ctx.strokeStyle='#8ea5bf'; ctx.beginPath();
    ctx.moveTo(sx,sy-TILE/2); ctx.lineTo(sx+TILE,sy); ctx.stroke();
  } else if(kind===EXIT){
    ctx.fillStyle='#a4ffd3'; ctx.fill(); ctx.strokeStyle='#1f7f60'; ctx.stroke();
  }
}
function drawCoffee(p){
  const {sx,sy}=iso(p.x,p.y);
  ctx.fillStyle='#ffb347'; ctx.fillRect(sx-4,sy-10,8,10);
  ctx.fillStyle='#fff'; ctx.fillRect(sx-3,sy-9,6,4);
}
function drawPlayer(){
  const {sx,sy}=iso(player.x,player.y);
  // shadow
  ctx.fillStyle='rgba(0,0,0,.35)'; ctx.beginPath(); ctx.ellipse(sx, sy+10, 10, 6, 0, 0, Math.PI*2); ctx.fill();
  // body
  ctx.fillStyle='var(--playerShirt)'; ctx.fillRect(sx-6, sy-18, 12, 14);
  ctx.fillStyle='var(--playerSkin)'; ctx.fillRect(sx-5, sy-26, 10, 8);
  ctx.fillStyle='var(--playerTie)';  ctx.fillRect(sx-1, sy-13, 2, 8);
  // i-frames flicker
  if(player.iFrames>0 && (player.iFrames%6)<3){
    ctx.fillStyle='rgba(255,255,255,.35)'; ctx.fillRect(sx-7,sy-28,14,28);
  }
}
function drawWorkers(){
  for(const w of workers){
    const {sx,sy}=iso(w.x,w.y);
    // simple worker sprite
    ctx.fillStyle='#ffd07a'; ctx.fillRect(sx-6,sy-8,12,8);   // head
    ctx.fillStyle='#9ac7ff'; ctx.fillRect(sx-7,sy,14,16);    // shirt
  }
}

/* ========= camera ========= */
function updateCamera(){
  const {sx,sy}=iso(player.x,player.y);
  const mx=c.width*0.35, my=c.height*0.3;
  if(sx<mx) cam.x+= (mx-sx)*0.08;
  if(sx>c.width-mx) cam.x-= (sx-(c.width-mx))*0.08;
  if(sy<my) cam.y+= (my-sy)*0.08;
  if(sy>c.height-my) cam.y-= (sy-(c.height-my))*0.08;
}

/* ========= movement / collision ========= */
function inBounds(x,y){ return x>=1 && y>=1 && x<=W-2 && y<=H-2; }
function solidAt(nx,ny){
  nx=Math.round(nx*100)/100; ny=Math.round(ny*100)/100;
  if(!inBounds(nx,ny)) return true;
  return grid[Math.round(ny)][Math.round(nx)]===SOLID;
}
function move(){
  let dx=0,dy=0;
  if(keys.left) dx-=player.speed;
  if(keys.right)dx+=player.speed;
  if(keys.up)   dy-=player.speed;
  if(keys.down) dy+=player.speed;
  if(dx&&dy){ dx*=0.7071; dy*=0.7071; } // iso diagonal damp
  const nx=player.x+dx, ny=player.y+dy;
  if(!solidAt(nx,player.y)) player.x=nx;
  if(!solidAt(player.x,ny)) player.y=ny;
  if(dx||dy){ player.facing = dx>=0?1:-1; player.step=(player.step+1)&7; }
}

/* ========= pickups + exit ========= */
function checkPickups(){
  for(let i=coffees.length-1;i>=0;i--){
    const p=coffees[i];
    if(Math.hypot(p.x-player.x,p.y-player.y)<0.6){
      coffees.splice(i,1);
      player.coffee++; coffeeEl.textContent=player.coffee;
      player.hp=Math.min(20,player.hp+2); hpEl.textContent=player.hp;
    }
  }
  // elevator exit
  if(grid[Math.round(player.y)][Math.round(player.x)]===EXIT){
    playing=false; $('#win').style.display='flex';
  }
}

/* ========= loop ========= */
let playing=true;
$('#againBtn').onclick = ()=>location.reload();
$('#retryBtn').onclick = ()=>location.reload();

function loop(){
  if(!playing) return;
  if(player.iFrames>0) player.iFrames--;
  move(); updateCamera(); stepWorkers();

  // draw
  const ctx=c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);
  for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ drawTile(x,y,grid[y][x]); } }
  drawWorkers();
  for(const p of coffees) drawCoffee(p);
  drawPlayer();

  if(showDebug){
    debug.textContent=`pos:(${player.x.toFixed(1)},${player.y.toFixed(1)}) coffee:${player.coffee} hp:${player.hp}\nworkers:${workers.length}`;
  }
  checkPickups();

  // death?
  if(player.hp<=0){ playing=false; $('#lose').style.display='flex'; }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
