<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Office Escape — Minimal (Map + Player)</title>
<style>
  :root{
    --bg:#0c1220; --ink:#e7eefc; --muted:#91a1c6;
    --tileA:#0f2034; --tileB:#0c1a2e; --wall:#d5deee; --shadow:#00000055;
    --player:#6be0ff; --accent:#58ffa8;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font:600 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;
    display:flex; flex-direction:column; align-items:center; gap:8px;
  }
  header{margin:8px 0 0}
  #wrap{
    position:relative; width:100vw; max-width:1100px; aspect-ratio:16/10;
    background:linear-gradient(180deg,#0c1425 0%, #0b1322 100%);
    border:1px solid #22314d; border-radius:14px; overflow:hidden;
  }
  canvas{width:100%; height:100%; display:block}
  .hud{
    position:absolute; left:10px; top:10px; padding:6px 10px;
    background:#0b1322d0; border:1px solid #22314d; border-radius:10px;
    font-weight:700; color:var(--muted);
  }
  /* Touch controls (hold to move) */
  .pads{width:100%; max-width:1100px; padding:10px 14px 16px}
  .row{display:flex; justify-content:center}
  .dpad{
    display:grid; grid-template-columns:repeat(3,64px); grid-template-rows:repeat(3,64px);
    gap:10px; touch-action:none;
  }
  .btn{
    width:64px; height:64px; border-radius:14px; border:1px solid #273b5d;
    background:#0b1526; box-shadow:0 8px 18px #0006 inset, 0 1px 0 #2a3c60;
    display:flex; align-items:center; justify-content:center; color:#cfe1ff;
    font-size:22px; user-select:none; -webkit-user-select:none;
  }
  .btn:active{filter:brightness(1.2)}
  @media (max-width: 540px){
    .btn{width:56px;height:56px}
    .dpad{grid-template-columns:repeat(3,56px);grid-template-rows:repeat(3,56px)}
  }
</style>
</head>
<body>
<header>Office Escape — <span style="color:var(--accent)">Minimal Build</span></header>
<div id="wrap">
  <canvas id="game" width="1280" height="800"></canvas>
  <div class="hud" id="debug">boot…</div>
</div>

<!-- TOUCH DPAD -->
<div class="pads">
  <div class="row">
    <div class="dpad" id="dpad">
      <div></div>          <div class="btn" data-key="ArrowUp">↑</div>      <div></div>
      <div class="btn" data-key="ArrowLeft">←</div> <div></div> <div class="btn" data-key="ArrowRight">→</div>
      <div></div>          <div class="btn" data-key="ArrowDown">↓</div>    <div></div>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== Canvas & HUD =====
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const dbg = document.getElementById('debug');

  // ===== Iso grid =====
  const TW = 64, TH = 32;          // on-screen diamond (2:1)
  const GW = 30, GH = 24;          // grid tiles
  const map = Array.from({length:GH},()=>Array(GW).fill(0)); // 0=floor, 1=wall

  // Simple readable maze-ish cubicles
  function addRectWall(x0,y0,x1,y1){
    for(let y=y0;y<=y1;y++)for(let x=x0;x<=x1;x++){
      if(x===x0||x===x1||y===y0||y===y1) map[y][x]=1;
    }
  }
  // Blocks & corridors
  addRectWall(3,3,10,8);
  addRectWall(14,4,24,9);
  addRectWall(4,12,11,19);
  addRectWall(16,12,27,21);
  for(let x=0;x<GW;x++){ if(x%3===0) map[14][x]=1; }
  for(let y=0;y<GH;y++){ if(y%4===0) map[y][8]=1; }
  map[14][9]=0; map[4][8]=0; map[12][8]=0; // openings

  // ===== Helpers =====
  const inBounds=(gx,gy)=> gx>=0&&gy>=0&&gx<GW&&gy<GH;
  const worldToScreen = (x,y) => ({ x:(x - y)*(TW/2), y:(x + y)*(TH/2) });

  // Camera follows player center
  const cam = {x:0,y:0};
  function centerOn(px,py){
    const s = worldToScreen(px,py);
    cam.x = s.x - cvs.width/2 + TW/2;
    cam.y = s.y - cvs.height/2 + TH/2;
  }

  // ===== Player =====
  const player = { x: 6.5, y: 20.5, spd: 4.5/60, w:.85, h:.85 };

  // ===== Input =====
  const keys = {ArrowUp:false,ArrowDown:false,ArrowLeft:false,ArrowRight:false,KeyW:false,KeyA:false,KeyS:false,KeyD:false};
  addEventListener('keydown',e=>{ if(keys.hasOwnProperty(e.code)){ keys[e.code]=true; e.preventDefault(); }});
  addEventListener('keyup',  e=>{ if(keys.hasOwnProperty(e.code)){ keys[e.code]=false; e.preventDefault(); }});
  // Touch dpad
  document.querySelectorAll('#dpad .btn').forEach(b=>{
    const code=b.dataset.key;
    const on=e=>{e.preventDefault(); keys[code]=true;};
    const off=e=>{e.preventDefault(); keys[code]=false;};
    b.addEventListener('touchstart',on,{passive:false});
    b.addEventListener('touchend',off,{passive:false});
    b.addEventListener('touchcancel',off,{passive:false});
    b.addEventListener('mousedown',on);
    b.addEventListener('mouseup',off);
    b.addEventListener('mouseleave',off);
  });

  // ===== Collision =====
  function tryMove(obj, dx, dy){
    let nx = obj.x + dx, ny = obj.y + dy;
    const hw=obj.w/2*0.9, hh=obj.h/2*0.9;
    const corners = [
      {x:nx-hw, y:ny-hh}, {x:nx+hw, y:ny-hh},
      {x:nx-hw, y:ny+hh}, {x:nx+hw, y:ny+hh},
    ];
    let blocked=false;
    for(const c of corners){
      const gx=Math.floor(c.x), gy=Math.floor(c.y);
      if(!inBounds(gx,gy) || map[gy][gx]===1){ blocked=true; break; }
    }
    if(!blocked){ obj.x=nx; obj.y=ny; }
  }

  // ===== Render =====
  function drawTile(gx,gy,kind){
    const s = worldToScreen(gx,gy);
    const x = s.x - cam.x, y = s.y - cam.y;
    // floor diamond
    ctx.beginPath();
    ctx.moveTo(x,           y + TH/2);
    ctx.lineTo(x + TW/2,    y);
    ctx.lineTo(x + TW,      y + TH/2);
    ctx.lineTo(x + TW/2,    y + TH);
    ctx.closePath();
    ctx.fillStyle = ((gx+gy)&1)? getVar('--tileA') : getVar('--tileB');
    ctx.fill();
    // wall cap
    if(kind===1){
      ctx.fillStyle = getVar('--wall');
      ctx.beginPath();
      ctx.moveTo(x+TW/2-18, y+TH/2);
      ctx.lineTo(x+TW/2,    y+TH/2-10);
      ctx.lineTo(x+TW/2+18, y+TH/2);
      ctx.lineTo(x+TW/2,    y+TH/2+10);
      ctx.closePath();
      ctx.fill();
    }
  }
  function drawPlayer(){
    const s = worldToScreen(player.x, player.y);
    const x = s.x - cam.x + TW/2, y = s.y - cam.y + TH/2;
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.beginPath(); ctx.ellipse(x, y+6, 14, 8, 0, 0, Math.PI*2); ctx.fill();
    // body
    ctx.fillStyle = getVar('--player');
    ctx.fillRect(x-8, y-22, 16, 24);
    // head
    ctx.fillStyle = '#ffd7b0'; ctx.fillRect(x-7, y-32, 14, 10);
    // tie
    ctx.fillStyle = '#ff536b'; ctx.fillRect(x-1, y-16, 2, 10);
  }
  function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  // ===== Loop =====
  let last=0;
  function frame(ts){
    const dt = Math.min(32, ts-last)||16; last=ts;

    // Input (isometric directions)
    const up   = keys.ArrowUp||keys.KeyW;
    const down = keys.ArrowDown||keys.KeyS;
    const left = keys.ArrowLeft||keys.KeyA;
    const right= keys.ArrowRight||keys.KeyD;
    const spd = player.spd * dt * 60;
    let mdx=0, mdy=0;
    if(up)    { mdx+=-1; mdy+=-1; }
    if(down)  { mdx+=+1; mdy+=+1; }
    if(left)  { mdx+=-1; mdy+=+1; }
    if(right) { mdx+=+1; mdy+=-1; }
    if(mdx||mdy){
      const len = Math.hypot(mdx,mdy);
      tryMove(player, (mdx/len)*spd, (mdy/len)*spd);
    }

    // Camera follow
    centerOn(player.x, player.y);

    // Draw
    ctx.clearRect(0,0,cvs.width,cvs.height);
    ctx.save();
    ctx.translate(cvs.width/2, 100);
    ctx.translate(-cvs.width/2, 0);
    for(let y=0;y<GH;y++)for(let x=0;x<GW;x++) drawTile(x,y,map[y][x]);
    drawPlayer();
    ctx.restore();

    // HUD
    const fps = (1000/Math.max(1,dt)).toFixed(0);
    dbg.textContent = `OK • fps:${fps} • pos:(${player.x.toFixed(1)},${player.y.toFixed(1)})`;
    requestAnimationFrame(frame);
  }

  // Crisp rendering on any screen
  function fit(){
    const r = document.getElementById('wrap').getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio||1);
    cvs.width = Math.floor(r.width * dpr);
    cvs.height = Math.floor(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', fit, {passive:true});
  fit(); requestAnimationFrame(frame);
})();
</script>
</body>
</html>
